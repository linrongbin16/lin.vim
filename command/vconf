#! /usr/bin/env python3
# -*- coding:utf-8 -*-
# Copyright 2018-  <linrongbin16@gmail.com>

import sys
import getopt
import os
import time
import shutil
import click

sys.path.append(".")
import util


def is_ascii_char(s):
    return all(ord(c) < 128 for c in s)


def header_path(s):
    if util.is_windows():
        return f'-I"{s}"'
    else:
        return f"-I{s}"


def os_listdir_wrapper(d):
    try:
        return os.listdir(d)
    except:
        return []


def git_repo_headers():
    try:
        root, _ = util.run("git", "rev-parse", "--show-toplevel")
        root = root[0].strip()
        hds = util.list_dirs(root, False, 3)
        return [header_path(x) for x in hds]
    except:
        return []


def windows_sdk_headers():
    hds = []
    # -I"C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.14.26428\\include"
    for release in os_listdir_wrapper(
            "C:\\Program Files (x86)\\Microsoft Visual Studio\\"):
        current_release = "C:\\Program Files (x86)\\Microsoft Visual Studio\\%s\\Community\\VC\\Tools\\MSVC\\" % (
            release)
        if not os.path.exists(current_release):
            continue
        if not os.path.isdir(current_release):
            continue
        for version in os_listdir_wrapper(current_release):
            current_version = (
                "C:\\Program Files (x86)\\Microsoft Visual Studio\\%s\\Community\\VC\\Tools\\MSVC\\%s\\include"
                % (release, version))
            if not os.path.exists(current_version) or not os.path.isdir(
                    current_version):
                continue
            hds.append(header_path(current_version))
    # -I"C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.17134.0\\ucrt"
    for version in os_listdir_wrapper(
            "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\"):
        current_version = "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\%s\\ucrt" % (
            version)
        if not os.path.exists(current_version) or not os.path.isdir(
                current_version):
            continue
        hds.append(header_path(current_version))
    # C:\\Program Files\\LLVM headers
    win_clang_list = [
        "C:\\Program Files\\LLVM\\include\\clang-c",
        "C:\\Program Files\\LLVM\\include\\llvm",
        "C:\\Program Files\\LLVM\\include\\llvm-c",
    ]
    for hd in win_clang_list:
        if not os.path.exists(hd) or not os.path.isdir(hd):
            continue
        hds.append(header_path(hd))
    return hds


def current_headers():
    hds = []
    hds.append(header_path("."))
    for f in util.list_files(".", False, 3):
        hds.append(header_path(f))
    return hds


def compile_commands(debug):
    gen_folder = f".vconf.{str(time.time())}"
    os.system(f"cmake -B {gen_folder} -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .")
    if not os.path.exists(f"{gen_folder}/compile_commands.json"):
        raise RuntimeError(
            "failed to generate `{gen_folder}/compile_commands.json`")
    shutil.copyfile(f"{gen_folder}/compile_commands.json",
                    "compile_commands.json")
    shutil.rmtree(gen_folder, ignore_errors=True)
    print("[vcmd] generate `compile_commands.json`")


def compile_flags(debug):
    fp = open("compile_flags.txt", "w")
    c = current_headers()
    if debug:
        print(f"current directory headers:{c}")
    w = windows_sdk_headers()
    if debug:
        print(f"windows sdk headers:{w}")
    g = git_repo_headers()
    if debug:
        print(f"git repo headers:{g}")
    for x in c:
        fp.write(f"{x}\n")
    for x in w:
        fp.write(f"{x}\n")
    for x in g:
        fp.write(f"{x}\n")
    fp.close()
    print("[vcmd] generate `compile_flags.txt`")


def sub_cli_clangd(debug):
    if util.is_windows() or not os.path.exists("CMakeLists.txt"):
        if debug:
            if util.is_windows():
                print(
                    "[vcmd] Windows Platform, generating `compile_flags.txt` ..."
                )
            elif not os.path.exists("CMakeLists.txt"):
                print(
                    "[vcmd] CMakeLists.txt missing, generating `compile_flags.txt` ..."
                )
        compile_flags(debug)
    else:
        print(
            "[vcmd] Non-Windows Platform and CMakeLists.txt exist, generate `compile_commands.json` ..."
        )
        compile_commands(debug)


def sub_cli_sshkey(email, debug):
    os.system(f"ssh-keygen -t rsa -b 4096 -C '{email}'")
    os.system("touch ~/.ssh/authorized_keys")
    os.system("chmod -R 700 ~/.ssh")
    os.system("chmod 600 ~/.ssh/authorized_keys")
    os.system("chmod 600 ~/.ssh/id_rsa")
    os.system("chmod 600 ~/.ssh/id_rsa.pub")


def brew_mirror():
    mirrors = [
        'git -C "$(brew --repo)" remote set-url origin https://mirrors.ustc.edu.cn/brew.git',
        'git -C "$(brew --repo homebrew/core)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git',
        'git -C "$(brew --repo homebrew/cask)" remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git',
    ]
    for cmd in mirrors:
        os.system(cmd)


def pip3_mirror():
    mirrors = [
        "pip3 config set global.index-url https://mirrors.ustc.edu.cn/pypi/web/simple",
    ]
    for cmd in mirrors:
        os.system(cmd)


def npm_mirror():
    mirrors = [
        "npm config set registry https://registry.npm.taobao.org",
    ]
    for cmd in mirrors:
        os.system(cmd)


def ubuntu_mirror():
    print(
        "[vcmd] replace 'archive.ubuntu/com' to 'mirrors.ustc.edu.cn' in /etc/apt/sources.list"
    )
    util.backup_file("/etc/apt/sources.list")
    if os.path.exists("/etc/apt/source.list"):
        replace_cmd = "sudo sed -i 's/archive.ubuntu.com/mirrors.ustc.edu.cn/g' /etc/apt/sources.list"
        os.system(replace_cmd)
    print(
        "[vcmd] for ubuntu version focal(20.04) bionic(18.04) artful(17.10) xenial(16.04) trusty(14.04)"
    )
    print("[vcmd] you could also manually edit source.list like below")
    mirror_content = """
# [vcmd] replace xenial with other ubuntu version for your needs
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-security main restricted universe multiverse

# proposed repos not recommended
# deb https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
# deb-src https://mirrors.ustc.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse
"""
    print(mirror_content)
    print(
        "[vcmd] please see http://mirrors.ustc.edu.cn/help/ubuntu.html for more details"
    )


def debian_mirror():
    print(
        "[vcmd] replace 'deb.debian.org' to 'mirrors.ustc.edu.cn' in /etc/apt/sources.list"
    )
    util.backup_file("/etc/apt/sources.list")
    if os.path.exists("/etc/apt/source.list"):
        replace_cmd = "sudo sed -i 's/deb.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list"
        os.system(replace_cmd)
    print("[vcmd] you could also manually edit source.list like below")
    mirror_content = """
deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free
# deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-free
deb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free
# deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free

# proposed repos not recommended
# deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free
# deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free
"""
    print(mirror_content)
    print(
        "[vcmd] please see http://mirrors.ustc.edu.cn/help/debian.html for more details"
    )


def fedora_mirror():
    print(
        "[vcmd] replace fedora.repo fedora-modular.repo fedora-updates.repo fedora-updates-modular.repo in /etc/yum.repos.d/"
    )
    replace_cmd = """sudo sed -e 's|^metalink=|#metalink=|g' \\
         -e 's|^#baseurl=http://download.fedoraproject.org/pub/fedora/linux|baseurl=https://mirrors.ustc.edu.cn/fedora|g' \\
         -i.bak \\
         /etc/yum.repos.d/fedora.repo \\
         /etc/yum.repos.d/fedora-modular.repo \\
         /etc/yum.repos.d/fedora-updates.repo \\
         /etc/yum.repos.d/fedora-updates-modular.repo"""
    print(replace_cmd)
    os.system(replace_cmd)
    print(
        "[vcmd] please see http://mirrors.ustc.edu.cn/help/fedora.html for more details"
    )


def manjaro_mirror():
    print("[vcmd] update manjaro mirror to China")
    update_mirror_cmd = "sudo pacman-mirrors -i -c China -m rank"
    refresh_mirror_cmd = "sudo pacman -Syy"
    os.system(update_mirror_cmd)
    os.system(refresh_mirror_cmd)


def sub_cli_mirror(mirror, debug):
    if mirror == "brew":
        brew_mirror()
    elif mirror == "npm":
        npm_mirror()
    elif mirror == "pip3":
        pip3_mirror()
    elif mirror == "ubuntu":
        ubuntu_mirror()
    elif mirror == "debian":
        debian_mirror()
    elif mirror == "fedora":
        fedora_mirror()
    elif mirror == "manjaro":
        manjaro_mirror()
    else:
        print(f"[vcmd] unknown mirror option:{mirror}")


@click.command()
@click.option(
    "-c",
    "--clangd",
    is_flag=True,
    help=
    "generate compile_commands.json/compile_flags.txt for clangd code complete",
)
@click.option("-s",
              "--sshkey",
              required=False,
              help="generate new ssh keys with email address in ~/.ssh")
@click.option("-m",
              "--mirror",
              type=click.Choice([
                  "brew", "npm", "pip3", "ubuntu", "debian", "fedora",
                  "manjaro"
              ]),
              required=False,
              help="configure mirror")
@click.option("--debug", is_flag=True, help="debug mode")
def vconf(clangd, sshkey, mirror, debug):
    """
Configure tool for system

Example:

\b
```
$ vconf -c
[vcmd] Non-Windows Platform and CMakeLists.txt exist, generate `compile_commands.json` ...
-- The CXX compiler identification is AppleClang 12.0.0.12000032
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Check for working CXX compiler: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/c++ - skipped
-- Detecting CXX compile features
-- Detecting CXX compile features - done
CMAKE_BUILD_TYPE:
-- Found PkgConfig: /usr/local/bin/pkg-config (found version "0.29.2")
-- Looking for C++ include pthread.h
-- Looking for C++ include pthread.h - found
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success
-- Found Threads: TRUE
-- Found Python: /usr/local/Frameworks/Python.framework/Versions/3.9/bin/python3.9 (found version "3.9.10") found components: Interpreter Development Development.Module Development.Embed
-- Checking for module 'jemalloc'
--   Found jemalloc, version 5.2.1_0
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/linrongbin16/workspace/github/hello-cpp/.vconf.1644556264.228266
[vcmd] generate `compile_commands.json`
```
    """
    if debug:
        print(f"clangd:{clangd}, sshkey:{sshkey}, mirror:{mirror}")
    if clangd:
        sub_cli_clangd(debug)
    elif sshkey:
        sub_cli_sshkey(sshkey, debug)
    elif mirror:
        sub_cli_mirror(mirror, debug)
    else:
        print(
            f"[vcmd] unknown option, please try `vconf --help` for more information"
        )


if __name__ == '__main__':
    vconf()
